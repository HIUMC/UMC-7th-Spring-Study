# 상품 수정

```java
@GetMapping("/items/{itemId}/edit")
public String updateItemForm(@PathVariable("itemId") Long itemId, Model model) {
    Book item = (Book) itemService.findOne(itemId); // 예제 단순화 위한 다운 캐스팅(추천X)

    BookForm form = new BookForm();
    form.setId(item.getId());
    form.setName(item.getName());
    form.setPrice(item.getPrice());
    form.setStockQuantity(item.getStockQuantity());
    form.setAuthor(item.getAuthor());
    form.setIsbn(item.getIsbn());

    model.addAttribute("form", form);
    return "items/updateItemForm";
}

@PostMapping("/items/{itemId}/edit")
public String updateItem(@PathVariable Long itemId, @ModelAttribute("form") BookForm form) {

    Book book = new Book();
    book.setId(form.getId());
    book.setName(form.getName());
    book.setPrice(form.getPrice());
    book.setStockQuantity(form.getStockQuantity());
    book.setAuthor(form.getAuthor());
    book.setIsbn(form.getIsbn());

    itemService.saveItem(book);
    return "redirect:/items";
}
```

[`@ModelAttribute(””)` 에 대해](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%91%E1%85%AE%E1%86%B7%20%E1%84%89%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%20147d916bc5a880228803e13cd0880c4a/@ModelAttribute(%E2%80%9D%E2%80%9D)%20%E1%84%8B%E1%85%A6%20%E1%84%83%E1%85%A2%E1%84%92%E1%85%A2%20147d916bc5a880d090dae6d66a1c270b.md)

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head th:replace="fragments/header :: header" />
<body>
<div class="container">
  <div th:replace="fragments/bodyHeader :: bodyHeader"/>
  <form th:object="${form}" method="post">
    <!-- id -->
    <input type="hidden" th:field="*{id}" />
    <div class="form-group">
      <label th:for="name">상품명</label>
      <input type="text" th:field="*{name}" class="form-control"
             placeholder="이름을 입력하세요" />
    </div>
    <div class="form-group">
      <label th:for="price">가격</label>
      <input type="number" th:field="*{price}" class="form-control"
             placeholder="가격을 입력하세요" />
    </div>
    <div class="form-group">
      <label th:for="stockQuantity">수량</label>
      <input type="number" th:field="*{stockQuantity}" class="form-control" placeholder="수량을 입력하세요" />
    </div>
    <div class="form-group">
      <label th:for="author">저자</label>
      <input type="text" th:field="*{author}" class="form-control"
             placeholder="저자를 입력하세요" />
    </div>
    <div class="form-group">
      <label th:for="isbn">ISBN</label>
      <input type="text" th:field="*{isbn}" class="form-control"
             placeholder="ISBN을 입력하세요" />
    </div>
    <button type="submit" class="btn btn-primary">Submit</button>
  </form>
  <div th:replace="fragments/footer :: footer" />
</div> <!-- /container -->
</body>
</html>

```

# 변경 감지와 병합(merge)

---

- `saveItem()`을 타고가보자.

### 컨트롤러

```java
@PostMapping("/items/{itemId}/edit")
public String updateItem(@PathVariable Long itemId, @ModelAttribute("form") BookForm form) {

    Book book = new Book();
    book.setName(form.getName());
    book.setPrice(form.getPrice());
    book.setStockQuantity(form.getStockQuantity());
    book.setAuthor(form.getAuthor());
    book.setIsbn(form.getIsbn());

    itemService.saveItem(book);
    return "redirect:/items";
}
```

### 서비스

```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ItemService {

    private final ItemRepository itemRepository;

    @Transactional
    public void saveItem(Item item) {
        itemRepository.save(item);
    }

   ...
}
```

### 리포지토리

```java
@Repository
@RequiredArgsConstructor
public class ItemRepository {

    private final EntityManager em;

    public void save(Item item) {
        if (item.getId() == null) {
            em.persist(item);
        } else {
            em.merge(item);
        }
    }

    ...
}
```

- 이미 있는 item에 대한 수정이기 때문에, 최종적으로 `merge()`가 일어남을 알 수 있다.
- `merge()`는 준영속 상태의 엔티티를 영속 상태로 변경하는 기능이다.

# 준영속 상태란?

- 한때 영속 상태였으나, 영속성 컨텍스트에서 더이상 관리되지 않는 상태
- 영속성 컨텍스트에서 해당 엔티티를 제거하면 엔티티는 데이터베이스와의 연관을 잃고 준영속 상태가 된다.
    - `detatch()`, `clear()`, `close()` 와 같은 메서드를 통해 엔티티가 영속성 컨텍스트에서 분리되면 준영속 상태로 전환된다.

## 임의로 생성된 객체를 준영속 상태로 보는 경우

---

<aside>
🔥

아래와 같은 로직이 있다고 하자.

```java
// 비영속 상태
Member member = new Member();
member.setId(1L);

// 영속 상태로 전환
entityManager.merge(member); // JPA가 준영속 상태로 간주.

// 이후 트랜잭션 커밋 시점에 데이터베이스에 반영됨
transaction.commit();
```

- 임의로 생성한 member 객체가 **식별자를 가지도록 하면** 실제 준영속 상태는 아니지만, 준영속 상태로 간주할 수 있다!
- 따라서 `merge()` 메서드가 유효한 것
    - `merge()`는 준영속 상태의 엔티티를 영속 상태로 변경하는 기능!
</aside>

# 변경 감지 기능 사용

---

```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class ItemService {

		private final ItemRepository itemRepository;

    @Transactional
    public void updateItem(Long itemId, Book param) {
        Item findItem = itemRepository.findOne(itemId);
        findItem.setPrice(param.getPrice());
        findItem.setName(param.getName());
        findItem.setStockQuantity(param.getStockQuantity());
        
        /* ❓ 뭔가 들어가야 할까? */
    }
    
    ...
}
```

❗아무 것도 안해도 된다.

- `updateItem()` 은 트랜잭션 위에서 영속 상태 엔티티의 값을 변경하고 있다.
- 트랜잭션 커밋 시점에 JPA의 변경 감지(Dirty Checking)가 일어나서 변경된 내용을 자동으로 데이터베이스에 반영한다.

# `merge()`, 병합

---

![image.png](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%91%E1%85%AE%E1%86%B7%20%E1%84%89%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%20147d916bc5a880228803e13cd0880c4a/image.png)

- 위 코드와 비교해서, 병합 이후 반환까지도 포함하면 `merge()`의 동작 과정과 완전히 똑같다.

```java
 @Transactional
    public Itme updateItem(Long itemId, Book param) {
        Item findItem = itemRepository.findOne(itemId);
        findItem.setPrice(param.getPrice());
        findItem.setName(param.getName());
        findItem.setStockQuantity(param.getStockQuantity());
        
        return findItem;
	}
```

따라서

참고) 로직 추가를 위해 기존 `save()` 메서드에서 merge를 `Item mergeItem = em.merge(item);` 로 바꿔서 추가해나가면

```java
    public void save(Item item) {
        if (item.getId() == null) {
            em.persist(item);
        } else {
            Item mergeItem = em.merge(item);
            /* mergeItem을 사용하는 로직 추가 */
        }
    }
```

- `Item mergeItem = em.merge(item);` 에서
    - parameter에서 넘긴 item은 준영속 상태이고
    - mergeItem이 영속 상태이다.
    
    → 구분 필요 !! : 로직 추가해서 쓰려면 mergeItem을 써야함 주의
    

## 주의점

변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다. 병합 시 **값이 없으면 null로 업데이트할 위험**도 있다.

<aside>
⚠️

병합은 모든 필드를 교체한다 ❗❗

</aside>

# 가장 좋은 해결 방법

### ⭐ 엔티티를 변경할 때는 항상 변경 감지를 사용하자!

- 컨트롤러에서 어설프게 엔티티를 생성하지 말기
    - 수정 코드
        
        ```java
        @PostMapping("/items/{itemId}/edit")
        public String updateItem(@PathVariable Long itemId, @ModelAttribute("form") BookForm form) {
        
            itemService.updateItem(itemId, form);
            
            return "redirect:/items";
        }
        ```
        
- 트랜잭션이 있는 서비스 계층에 **식별자(id)**와 변경할 데이터 (파라미터 or DTO) 를 명확하게 전달하기
- 트랜잭션이 있는 **서비스 계층에서** **영속 상태의 엔티티를 조회**하고, 엔티티의 데이터를 **직접 변경**하기
    - 트랜잭션 커밋 시점에 변경 감지가 실행된다!